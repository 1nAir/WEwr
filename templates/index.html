<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wealthrate</title>
    <link rel="icon" type="image/webp" href="favicon.webp">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #f2f0ea;
            /* Lighter newspaper */
            --container-bg: #ffffff;
            --border-color: #c8c6be;
            --shadow-color: rgba(0, 0, 0, 0.08);
            --text-primary: #1a202c;
            --text-secondary: #718096;
            --text-heading-font: 'Georgia', serif;
            --hover-bg: #f7fafc;
            --header-gradient-start: #667eea;
            --header-gradient-end: #764ba2;
            --link-color: #5a67d8;
            --high-profit-bg: #c6f6d5;
            --high-profit-text: #22543d;
            --tooltip-bg: #2d3748;
            --tooltip-text: #f7fafc;
            --tooltip-border: #4a5568;
            --bonus-badge-bg: #fffaf0;
            --bonus-badge-text: #b7791f;
            --bonus-badge-border: #f6e05e;
            --button-bg: #ffffff;
            --button-border: #cbd5e0;
            --button-text: #4a5568;
            --button-hover-bg: #edf2f7;
            --button-hover-border: #a0aec0;
            --button-active-bg: #667eea;
            --button-active-text: white;
            --icon-fill: #4a5568;
        }

        body.dark-mode {
            --bg-color: #1a202c;
            --container-bg: #2d3748;
            --border-color: #4a5568;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --text-primary: #f7fafc;
            --text-secondary: #cbd5e0;
            --hover-bg: #4a5568;
            --link-color: #90cdf4;
            --high-profit-bg: #2f855a;
            --high-profit-text: #f0fff4;
            --tooltip-bg: #1a202c;
            --tooltip-text: #e2e8f0;
            --tooltip-border: #718096;
            --bonus-badge-bg: #4a371b;
            --bonus-badge-text: #f6e05e;
            --bonus-badge-border: #b7791f;
            --button-bg: #4a5568;
            --button-border: #4a5568;
            --button-text: #e2e8f0;
            --button-hover-bg: #2d3748;
            --button-hover-border: #718096;
            --icon-fill: #a0aec0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            padding: 20px;
            transition: background-color 0.3s;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 12px;
            box-shadow: 0 4px 12px var(--shadow-color);
            overflow: hidden;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }

        /* New Header & Tabs Styles */

        .site-header {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: var(--container-bg);
            margin-bottom: 20px;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        .site-title {
            font-family: var(--text-heading-font);
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
            letter-spacing: -0.5px;
            margin-bottom: 5px;
        }

        .update-info {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .warship-link {
            position: absolute;
            right: 20px;
            display: block;
            width: 80px;
            height: auto;
            transition: transform 0.2s;
        }

        .warship-link:hover {
            transform: scale(1.05);
        }

        .warship-link img {
            width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        .tabs-nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 0;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .tab-btn {
            padding: 10px 24px;
            background: var(--button-bg);
            border: 1px solid var(--button-border);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: var(--button-text);
            transition: all 0.2s;
            font-size: 14px;
        }

        .tab-btn:hover {
            background: var(--button-hover-bg);
        }

        .tab-btn.active {
            background: var(--button-active-bg);
            color: var(--button-active-text);
            border-color: var(--button-active-bg);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .coming-soon-pane {
            text-align: center;
            padding: 80px 20px;
            color: #a0aec0;
            font-size: 24px;
            font-weight: bold;
        }

        #theme-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #theme-toggle:hover {
            background-color: var(--hover-bg);
        }

        #theme-toggle svg {
            width: 26px;
            height: 26px;
            fill: var(--icon-fill);
            transition: fill 0.3s;
        }

        body.dark-mode #theme-icon-sun {
            display: block;
        }

        body.dark-mode #theme-icon-moon {
            display: none;
        }

        body:not(.dark-mode) #theme-icon-sun {
            display: none;
        }

        body:not(.dark-mode) #theme-icon-moon {
            display: block;
        }

        .guide-box {
            position: relative;
            display: inline-block;
        }

        .q-mark {
            width: 24px;
            height: 24px;
            background: var(--button-active-bg);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: help;
        }

        .guide-img {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: 0.2s;
            border: 1px solid #ddd;
            width: max-content;
            max-width: 90vw;
        }

        .guide-img img {
            max-width: 450px;
            height: auto;
            display: block;
        }

        .guide-box:hover .guide-img {
            visibility: visible;
            opacity: 1;
        }

        .table-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 0 15px 0;
        }

        .table-wrapper {
            overflow-x: auto;
            padding: 0 30px 30px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        thead {
            background: linear-gradient(135deg, var(--header-gradient-start) 0%, var(--header-gradient-end) 100%);
            color: white;
        }

        th {
            padding: 16px;
            text-align: right;
            cursor: pointer;
            border-right: 1px solid rgba(255, 255, 255, 0.15);
            white-space: nowrap;
        }

        th:first-child {
            text-align: left;
        }

        th.sort-asc::after {
            content: " ‚Üë";
        }

        th.sort-desc::after {
            content: " ‚Üì";
        }

        td {
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            vertical-align: middle;
            transition: background-color 0.2s;
        }

        /* tbody tr:hover { background: var(--hover-bg); } */
        .clickable {
            cursor: pointer;
        }

        /* Icon and Name styling */
        .item-cell {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 4px 0;
        }

        .item-icon {
            width: 42px;
            height: 42px;
            border-radius: 6px;
            object-fit: contain;
            flex-shrink: 0;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
        }

        .item-content {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            flex-grow: 1;
        }

        .item-name {
            font-weight: 700;
            color: var(--text-primary);
            font-size: 14px;
            line-height: 1.3;
            white-space: nowrap;
        }

        .item-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .bonus-badge {
            display: inline-flex;
            align-items: center;
            font-size: 11px;
            font-weight: 600;
            color: var(--bonus-badge-text);
            background: var(--bonus-badge-bg);
            padding: 3px 6px;
            border-radius: 6px;
            border: 1px solid var(--bonus-badge-border);
        }

        .deposit-timer {
            font-size: 10px;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            padding: 3px 8px;
            border-radius: 12px;
            line-height: 1.4;
        }

        .pp-col {
            font-weight: 600;
            color: var(--link-color);
        }

        .pp-col.high {
            background: var(--high-profit-bg);
            color: var(--high-profit-text);
        }

        .pp-cell {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .pp-main {
            font-size: 14px;
        }

        .pp-sub {
            font-size: 11px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            margin-top: 2px;
            font-weight: 500;
        }

        .fidelity-icon svg {
            width: 1em;
            height: 1em;
            stroke: var(--vmcoznmr, #e53e3e);
            paint-order: stroke;
            stroke-width: 12%;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: currentColor;
            color: #e53e3e;
            margin-right: 2px;
        }

        /* Tooltip Logic */
        .tooltip {
            position: relative;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: auto;
            min-width: 320px;
            max-width: 450px;
            background-color: var(--tooltip-bg);
            color: var(--tooltip-text);
            text-align: left;
            border-radius: 8px;
            padding: 12px;
            position: fixed;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            box-shadow: 0 8px 24px rgba(28, 37, 51, 0.3);
            border: 1px solid var(--tooltip-border);
            font-weight: 500;
            font-size: 12px;
            line-height: 1.3;
            pointer-events: none;
            white-space: normal;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Header Tooltip Styling */
        th.tooltip .tooltiptext {
            font-size: 12px;
            min-width: 300px;
        }

        /* Content Tooltip Styling */
        .formula-header {
            font-weight: 700;
            color: #63b3ed;
            margin-bottom: 4px;
            border-bottom: 1px solid var(--tooltip-border);
            padding-bottom: 2px;
            font-size: 13px;
            margin-top: 8px;
        }

        .formula-header:first-child {
            margin-top: 0;
        }

        .formula-step {
            color: var(--tooltip-text);
            font-family: monospace;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
        }

        .formula-result {
            color: #68d391;
            font-weight: 600;
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px solid var(--tooltip-border);
            font-family: monospace;
            text-align: right;
        }

        .formula-sub {
            color: #a0aec0;
            font-size: 10px;
            font-style: italic;
            margin-bottom: 2px;
        }

        .location-row {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: normal;
        }

        .val {
            color: #fff;
            font-weight: 600;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 20000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background-color: var(--container-bg);
            margin: 1% auto;
            padding: 10px;
            border-radius: 8px;
            width: 98%;
            max-width: none;
            height: 95vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .close {
            position: absolute;
            right: 15px;
            top: 10px;
            font-size: 32px;
            cursor: pointer;
            color: var(--text-secondary);
            z-index: 10;
            line-height: 1;
        }

        .modal-chart-container {
            flex-grow: 1;
            position: relative;
            width: 100%;
            min-height: 0;
        }

        /* Charts Section */
        .charts-container {
            padding: 20px 30px 30px;
            margin-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .charts-title {
            color: var(--text-primary);
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
        }

        .chart-wrapper {
            margin-bottom: 40px;
            height: auto;
            position: relative;
            background: var(--container-bg);
            border-radius: 8px;
            padding: 10px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 10px;
        }

        .chart-header h3 {
            margin: 0;
            color: var(--text-primary);
            font-size: 18px;
        }

        .chart-controls {
            display: flex;
            gap: 8px;
        }

        .chart-toggle-btn {
            background: var(--button-bg);
            border: 1px solid var(--button-border);
            color: var(--button-text);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chart-toggle-btn:hover {
            background: var(--button-hover-bg);
            border-color: var(--button-hover-border);
        }

        .legend-wrapper {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .custom-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-group {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 6px 10px;
            display: flex;
            flex-direction: column;
            min-width: 100px;
        }

        .legend-group-header {
            font-weight: 700;
            margin-bottom: 5px;
            cursor: pointer;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 3px;
            text-align: center;
        }

        .legend-group-header:hover {
            color: #3182ce;
        }

        .legend-item {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 2px 0;
            color: var(--text-secondary);
        }

        .legend-item.hidden {
            opacity: 0.4;
            text-decoration: line-through;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
            flex-shrink: 0;
        }

        .chart-canvas-container {
            height: 400px;
            position: relative;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            position: relative;
        }

        .controls button {
            cursor: pointer;
            padding: 6px 12px;
            border: 1px solid var(--button-border);
            background: var(--button-bg);
            border-radius: 6px;
            transition: all 0.2s;
            font-weight: 500;
            color: var(--button-text);
        }

        .controls button:hover {
            background: var(--button-hover-bg);
            border-color: var(--button-hover-border);
        }

        .controls button.active {
            background: var(--button-active-bg);
            color: var(--button-active-text);
            border-color: var(--button-active-bg);
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .site-header {
                align-items: center;
            }

            .site-title {
                font-size: 24px;
            }

            .guide-box {
                margin-left: 0;
                margin-top: 5px;
            }

            .table-wrapper {
                padding: 0 5px 20px;
            }

            th,
            td {
                padding: 8px 4px;
                font-size: 11px;
            }

            .item-cell {
                gap: 6px;
            }

            .item-icon {
                width: 30px;
                height: 30px;
            }

            .item-content {
                gap: 2px;
                flex-direction: column;
                align-items: flex-start;
            }

            .item-name {
                font-size: 11px;
                margin-right: 0;
            }

            .item-meta {
                margin-left: 0;
                gap: 1px;
                flex-direction: column;
                align-items: flex-start;
            }

            .bonus-badge {
                font-size: 9px;
                padding: 1px 3px;
            }

            .deposit-timer {
                font-size: 9px;
                padding: 1px 4px;
            }

            .pp-main {
                font-size: 12px;
            }

            .pp-sub {
                font-size: 10px;
            }

            .charts-container {
                padding: 15px 10px;
            }

            .controls {
                flex-wrap: wrap;
                gap: 8px;
            }

            .controls button {
                padding: 6px 10px;
                font-size: 12px;
                flex: 1 1 40%;
            }

            .controls label {
                width: 100%;
                justify-content: center;
                margin-left: 0 !important;
                margin-top: 5px;
            }

            .chart-canvas-container {
                height: 300px;
            }

            .guide-img {
                width: 300px;
                max-width: 90vw;
                left: 50%;
                right: auto;
                transform: translateX(-50%);
            }

            .guide-img img {
                width: 100%;
            }

            th.tooltip .tooltiptext {
                min-width: 200px;
                max-width: 250px;
                white-space: normal;
            }

            .tooltip .tooltiptext {
                max-width: 90vw;
            }

            .custom-legend {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 4px;
            }

            .legend-group {
                min-width: 0;
                padding: 4px;
            }

            .legend-group-header {
                font-size: 10px;
                margin-bottom: 2px;
            }

            .legend-item {
                font-size: 9px;
            }

            .legend-color {
                width: 8px;
                height: 8px;
                margin-right: 4px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- New Header -->
        <div class="site-header">
            <button id="theme-toggle" title="Toggle theme">
                <svg id="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path
                        d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM12 9c1.65 0 3 1.35 3 3s-1.35 3-3 3-3-1.35-3-3 1.35-3 3-3zm0-5h-1v3h1V4zm9.12 2.47l-.71.71a5.53 5.53 0 0 0-1.41-1.41l.71-.71c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41zM20 11h-3v1h3v-1zm-2.47 9.12l-.71-.71a5.53 5.53 0 0 0 1.41-1.41l.71.71c.39.39.39 1.02 0 1.41-.39.39-1.02.39-1.41 0zM12 20h1v-3h-1v3zm-9.12-2.47l.71-.71a5.53 5.53 0 0 0 1.41 1.41l-.71.71c-.39-.39-1.02-.39-1.41 0-.39-.39-.39-1.02 0-1.41zM4 13h3v-1H4v1zm2.47-9.12l.71.71a5.53 5.53 0 0 0-1.41 1.41l-.71-.71c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0z" />
                </svg>
                <svg id="theme-icon-moon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path
                        d="M12.3 4.88c.16.02.32.05.49.07C7.9 5.55 4.5 9.4 4.5 14c0 4.13 3.37 7.5 7.5 7.5.85 0 1.67-.14 2.44-.4l.25.63c-.83.33-1.72.51-2.69.51-4.97 0-9-4.03-9-9 0-4.56 3.35-8.33 7.79-8.92z" />
                </svg>
            </button>
            <div class="site-title">Wealthrate</div>
            <div class="update-info">Updated: <span id="updateTime" data-timestamp="{{ timestamp }}">just now</span>
            </div>
            <a href="https://app.warera.io/user/69635dc2d83cd4e381a66dce" target="_blank" class="warship-link">
                <img src="assets/ru_warship.webp" alt="Profile" onerror="this.style.display='none'">
            </a>
        </div>

        <!-- Tabs -->
        <div class="tabs-nav">
            <button class="tab-btn active" onclick="switchTab('profitability', this)">Profitability</button>
            <button class="tab-btn" onclick="switchTab('comingsoon', this)">Coming Soon (I hope)</button>
        </div>

        <!-- Tab 1: Profitability -->
        <div id="profitability" class="tab-content active">
            <div class="table-wrapper">
                <div class="table-top-bar">
                    <label
                        style="display: flex; align-items: center; cursor: pointer; font-size: 13px; color: var(--text-primary); font-weight: 600;">
                        <input type="checkbox" id="fidelitySort" onchange="toggleFidelitySort()"
                            style="margin-right: 6px;">
                        Sort by Fidelity
                    </label>
                    <div class="guide-box">
                        <div class="q-mark">?</div>
                        <div class="guide-img"><img src="assets/guide.webp" alt="Guide"
                                onerror="this.style.display='none'"></div>
                    </div>
                    <div id="sortInfo" style="font-size: 13px; color: var(--text-primary); font-weight: 600;">
                        Sorted by: <span id="currentSortLabel">Min ‚Çø/PP ‚Üì</span>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th style="cursor: default;">Product</th>
                            <th onclick="handleSort('min_pp')" class="tooltip">Min ‚Çø/PP
                                <span class="tooltiptext">
                                    Minimum profit in BTC per 1 Production Point.<br><br>
                                    Based on "Conservative" scenario: High resource costs (top 3 sell order avg), Low
                                    sell price (top 3 buy order avg).
                                </span>
                            </th>
                            <th onclick="handleSort('avg_pp')" class="tooltip">Avg ‚Çø/PP
                                <span class="tooltiptext">
                                    Average profit in BTC per 1 Production Point.<br><br>
                                    Based on Market Average prices for resources and product.
                                </span>
                            </th>
                            <th onclick="handleSort('max_pp')" class="tooltip">Max ‚Çø/PP
                                <span class="tooltiptext">
                                    Maximum profit in BTC per 1 Production Point.<br><br>
                                    Based on "Optimistic" scenario: Low resource costs (top 3 buy order avg), High sell
                                    price (top 3 sell order avg).
                                </span>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>

            <div class="charts-container">
                <h2 class="charts-title">History Charts</h2>

                <!-- Time Controls -->
                <div class="controls" id="timeControls" style="margin-bottom: 20px;">
                    <button id="btn24" onclick="setPeriod(24)" class="active">24 Hours</button>
                    <button id="btn72" onclick="setPeriod(72)">3 Days</button>
                    <button id="btn168" onclick="setPeriod(168)">7 Days</button>
                    <button id="btn0" onclick="setPeriod(0)">All Time</button>
                </div>

                <!-- Metric Controls -->
                <div class="controls" style="margin-bottom: 15px;">
                    <button id="btn_min_pp" onclick="setMetric('min_pp')" class="active">Min ‚Çø/PP</button>
                    <button id="btn_avg_pp" onclick="setMetric('avg_pp')">Avg ‚Çø/PP</button>
                    <button id="btn_max_pp" onclick="setMetric('max_pp')">Max ‚Çø/PP</button>
                </div>

                <div class="chart-wrapper">
                    <div class="chart-header">
                        <h3 id="chartTitle"></h3>
                    </div>
                    <div class="chart-canvas-container">
                        <canvas id="mainChart"></canvas>
                    </div>
                    <div class="legend-wrapper">
                        <button class="chart-toggle-btn" onclick="toggleAll('mainChart')"
                            style="margin-bottom: 8px;">Toggle All</button>
                        <div id="mainChart-legend" class="custom-legend"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tab 2: Coming Soon -->
        <div id="comingsoon" class="tab-content">
            <div class="coming-soon-pane">
                üöß Coming Soon üöß
            </div>
        </div>
    </div>

    <div id="chartModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeChartModal()">&times;</span>
            <div class="modal-chart-container">
                <canvas id="modalChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        const tableData = {{ table_data_json | safe }};
        const labels = {{ metric_labels_json | safe }};
        const itemColors = {{ item_colors_json | safe }};

        const productionLines = {{ production_lines_json | safe }};
        let currentSort = { col: 'min_pp', dir: 'desc' };
        let currentMetric = 'min_pp';
        let sortByFidelity = false;
        let chartInstances = {};
        let modalChartInstance = null;
        let mobileAnnotation = null;
        let chart = null;

        // --- THEME SWITCHER ---
        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;

        function applyTheme(theme) {
            if (theme === 'dark') {
                body.classList.add('dark-mode');
            } else {
                body.classList.remove('dark-mode');
            }
        }

        themeToggle.addEventListener('click', () => {
            const newTheme = body.classList.contains('dark-mode') ? 'light' : 'dark';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);
            renderCharts(); // Re-render charts for new theme
        });

        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            applyTheme(savedTheme);
        } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            applyTheme('dark');
        }

        function switchTab(tabId, btn) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            btn.classList.add('active');
        }

        function toggleFidelitySort() {
            sortByFidelity = document.getElementById('fidelitySort').checked;
            updateSortLabel();
            renderTable();
        }

        function openChartModal() {
            const mainChart = chartInstances.mainChart;
            if (!mainChart) return;

            const modal = document.getElementById('chartModal');
            const canvas = document.getElementById('modalChart');
            const ctx = canvas.getContext('2d');

            const data = JSON.parse(JSON.stringify(mainChart.data));
            const options = JSON.parse(JSON.stringify(mainChart.options));

            options.plugins.tooltip.callbacks.label = mainChart.options.plugins.tooltip.callbacks.label;
            options.scales.y.ticks.callback = mainChart.options.scales.y.ticks.callback;
            options.plugins.legend.display = true;
            options.plugins.legend.position = 'bottom';
            options.maintainAspectRatio = false;

            modalChartInstance = new Chart(ctx, { type: 'line', data: data, options: options });
            modal.style.display = 'block';
        }

        function closeChartModal() {
            document.getElementById('chartModal').style.display = 'none';
            if (modalChartInstance) { modalChartInstance.destroy(); modalChartInstance = null; }

        }

        function setMetric(metric) {
            currentMetric = metric;
            // Update buttons
            ['min_pp', 'avg_pp', 'max_pp'].forEach(m => {
                document.getElementById('btn_' + m).classList.toggle('active', m === metric);
            });
            // Update Title
            document.getElementById('chartTitle').innerText = labels[metric];
            renderCharts();
        }

        function updateRelativeTime() {

            const timeElement = document.getElementById('updateTime');
            const timestamp = parseInt(timeElement.getAttribute('data-timestamp'));
            const now = Math.floor(Date.now() / 1000);
            const diff = now - timestamp;

            let timeText;
            if (diff < 60) { timeText = 'just now'; }
            else if (diff < 3600) { timeText = Math.floor(diff / 60) + 'm ago'; }
            else if (diff < 86400) {
                const h = Math.floor(diff / 3600), m = Math.floor((diff % 3600) / 60);
                timeText = m > 0 ? `${h}h${m}m ago` : `${h}h ago`;
            } else { timeText = Math.floor(diff / 86400) + 'd ago'; }

            timeElement.textContent = timeText;
        }


        updateRelativeTime();
        setInterval(updateRelativeTime, 1000);

        function getFullTooltip(row, type) {
            // Type is 'min', 'avg', 'max'
            const res = row.resources || [];

            // 1. Title & Location
            let typeLabel = type === 'min' ? 'Min' : (type === 'max' ? 'Max' : 'Avg');
            let title = `${row.pretty_name} ${typeLabel} PP`;

            let html = `<div class="formula-header" style="margin-top:0; font-size:14px; border-bottom: 2px solid var(--border-color); padding-bottom:4px; margin-bottom:6px;">${title}</div>
                        <div class="location-row" style="margin-bottom:4px"><span>${row.region_name}, ${row.country_name}</span></div>
                        <div class="formula-step"><span>Bonus:</span> <span>${row.region_bonus}% (Deposit) + ${row.country_bonus}% (Country)</span></div>
                        <div class="formula-step" style="border-top:1px dashed rgba(255,255,255,0.2); padding-top:2px; margin-top:2px"><span>Total:</span> <span style="color:#fbd38d">${row.total_bonus}% (x${row.bonus_multiplier.toFixed(4)})</span></div>`;

            // 2. Base Profit Section (Sell Price - Costs)
            let priceLabel = type === 'min' ? 'Top 3 Buy' : (type === 'max' ? 'Top 3 Sell' : 'Avg');
            let costLabel = type === 'min' ? 'Top 3 Sell' : (type === 'max' ? 'Top 3 Buy' : 'Avg');
            let baseSellPrice = row['base_' + type + '_price'];
            let netProfit = row[type + '_price']; // This is pre-calculated in Python (Sell - Cost)

            html += `<div class="formula-header">Profit</div>
                     <div class="formula-step"><span>Sell (${priceLabel}):</span> <span class="val">${baseSellPrice.toFixed(3)}</span></div>`;

            if (res.length) {
                let totalCost = 0;
                let costHtml = '';
                res.forEach(r => {
                    // For min profit, we buy at max cost. For max profit, we buy at min cost.
                    let costPrice = type === 'min' ? r.max : (type === 'max' ? r.min : r.avg);
                    let subCost = r.quantity * costPrice;
                    totalCost += subCost;
                    costHtml += `<div class="formula-step"><span>- ${r.quantity}x ${r.pretty_name} @ ${costPrice.toFixed(3)} (${costLabel}):</span> <span>${subCost.toFixed(3)}</span></div>`;
                });
                html += costHtml;
                html += `<div class="formula-result">${baseSellPrice.toFixed(3)} - ${totalCost.toFixed(3)} = ${netProfit.toFixed(3)}</div>`;
            } else {
                html += `<div class="formula-result">${netProfit.toFixed(3)}</div>`;
            }

            // 3. Efficiency Math Section
            let finalVal = row[type + '_pp'];
            html += `<div class="formula-header">Efficiency</div>
                     <div class="formula-step"><span>Base Profit:</span> <span class="val">${netProfit.toFixed(3)}</span></div>
                     <div class="formula-step"><span>Multiplier:</span> <span class="val">x${row.bonus_multiplier.toFixed(4)}</span></div>
                     <div class="formula-step"><span>Production Points:</span> <span class="val">√∑${row.production_points}</span></div>
                     <div class="formula-result">(${netProfit.toFixed(3)} √ó ${row.bonus_multiplier.toFixed(4)}) √∑ ${row.production_points} = ${finalVal.toFixed(3)} ‚Çø/PP</div>`;

            // 4. Fidelity Bonus Section
            let pp5 = (netProfit * (row.bonus_multiplier + 0.05)) / row.production_points;
            let pp10 = (netProfit * (row.bonus_multiplier + 0.10)) / row.production_points;

            html += `<div class="formula-header" style="color:#e53e3e;">Fidelity</div>
                     <div class="formula-step"><span>+5% (x${(row.bonus_multiplier + 0.05).toFixed(4)}):</span> <span class="val">${pp5.toFixed(3)}</span></div>
                     <div class="formula-step"><span>+10% (x${(row.bonus_multiplier + 0.10).toFixed(4)}):</span> <span class="val">${pp10.toFixed(3)}</span></div>`;

            return html;
        }

        function getIcon(itemName) {
            return `<img src="assets/${itemName}.webp" class="item-icon" onerror="this.style.display='none'" alt="">`;
        }


        function renderTable() {
            const tbody = document.getElementById('tableBody');
            const data = [...tableData].sort((a, b) => {
                let v1, v2;
                if (sortByFidelity && ['min_pp', 'avg_pp', 'max_pp'].includes(currentSort.col)) {
                    const getFidelity = (row, metric) => {
                        const priceMetric = metric.replace('_pp', '_price');
                        const baseProfit = row[priceMetric];
                        return (baseProfit * (row.bonus_multiplier + 0.10)) / row.production_points;
                    };
                    v1 = getFidelity(a, currentSort.col);
                    v2 = getFidelity(b, currentSort.col);
                } else {
                    v1 = a[currentSort.col];
                    v2 = b[currentSort.col];
                }
                return currentSort.dir === 'asc' ? (v1 > v2 ? 1 : -1) : (v1 < v2 ? 1 : -1);
            });

            tbody.innerHTML = data.map(row => {
                const isHigh = row.max_pp >= 0.21;

                const bonusText = Number(row.total_bonus.toFixed(2));
                // Bonus Badge
                const bonusBadge = `
                    <div class="bonus-badge">
                        <div style="display: flex; align-items: center; margin-right: 2px;">
                            <svg style="width: 1.2em; height: 1.2em;" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M14.79,10.62L3.5,21.9L2.1,20.5L13.38,9.21L14.79,10.62M19.27,7.73L19.86,7.14L19.07,6.35L19.71,5.71L18.29,4.29L17.65,4.93L16.86,4.14L16.27,4.73C14.53,3.31 12.57,2.17 10.47,1.37L9.64,3.16C11.39,4.08 13,5.19 14.5,6.5L14,7L17,10L17.5,9.5C18.81,11 19.92,12.61 20.84,14.36L22.63,13.53C21.83,11.43 20.69,9.47 19.27,7.73Z"></path>
                            </svg>
                        </div>
                        <span>+${bonusText}%</span>
                    </div>
                `;

                let depositInfo = '';
                if (row.deposit_ends_at) {
                    const end = new Date(row.deposit_ends_at);
                    const now = new Date();
                    const diff = end - now;

                    if (diff > 0) {
                        const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                        const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

                        let timeLeft = '';
                        if (days > 0) timeLeft += `${days}d `;
                        timeLeft += `${hours}h ${minutes}m`;

                        let color = '#38A169'; let bgColor = 'rgba(56, 161, 105, 0.1)'; // Green
                        if (diff < 12 * 3600 * 1000) { color = '#E53E3E'; bgColor = 'rgba(229, 62, 62, 0.1)'; } // Red
                        else if (diff < 48 * 3600 * 1000) { color = '#DD6B20'; bgColor = 'rgba(221, 107, 32, 0.1)'; } // Yellow

                        depositInfo = `<div class="deposit-timer" style="color: ${color}; background-color: ${bgColor}">‚è≥ ${timeLeft}</div>`;
                    }
                }

                // Helper to render PP cell with Fidelity
                const renderPPCell = (metric) => {
                    const baseProfit = row[metric.replace('_pp', '_price')];
                    const pp10 = (baseProfit * (row.bonus_multiplier + 0.10)) / row.production_points;

                    return `
                        <div class="pp-cell">
                            <span class="pp-main">${row[metric].toFixed(3)}</span>
                            <span class="pp-sub">
                                <span class="fidelity-icon">
                                    <svg viewBox="0 0 24 24"><path d="M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z"></path></svg>
                                </span>
                                ${pp10.toFixed(3)}
                            </span>
                        </div>
                    `;
                };

                let displayName = row.pretty_name;
                if (window.innerWidth <= 768) {
                    const shortNames = {
                        'coca': 'Myst. Plant',
                        'heavyAmmo': 'H. Ammo',
                        'lightAmmo': 'L. Ammo'
                    };
                    displayName = shortNames[row.item] || row.pretty_name;
                }

                return `<tr>
                    <td>
                        <div class="item-cell">
                            ${getIcon(row.item)}
                            <div class="item-content">
                                <span class="item-name">${displayName}</span>
                                <div class="item-meta">
                                    ${depositInfo}
                                    ${bonusBadge}
                                </div>
                            </div>
                        </div>
                    </td>
                    <td class="pp-col tooltip">${renderPPCell('min_pp')}<span class="tooltiptext">${getFullTooltip(row, 'min')}</span></td>
                    <td class="pp-col tooltip">${renderPPCell('avg_pp')}<span class="tooltiptext">${getFullTooltip(row, 'avg')}</span></td>
                    <td class="pp-col tooltip ${isHigh ? 'high' : ''}">${renderPPCell('max_pp')}<span class="tooltiptext">${getFullTooltip(row, 'max')}</span></td>
                </tr>`;
            }).join('');

            setupTooltips();
        }

        function handleSort(col) {
            currentSort.dir = (currentSort.col === col && currentSort.dir === 'desc') ? 'asc' : 'desc';
            currentSort.col = col;
            updateSortLabel();
            renderTable();
        }

        function updateSortLabel() {
            const labels = { 'min_pp': 'Min ‚Çø/PP', 'avg_pp': 'Avg ‚Çø/PP', 'max_pp': 'Max ‚Çø/PP', 'item': 'Product' };
            let text = labels[currentSort.col] || currentSort.col;
            text += currentSort.dir === 'asc' ? ' ‚Üë' : ' ‚Üì';
            const el = document.getElementById('currentSortLabel');
            if (el) el.textContent = text;
        }

        function setupTooltips() {

            document.querySelectorAll('.tooltip').forEach(el => {
                el.onmouseenter = function () {
                    const t = this.querySelector('.tooltiptext');
                    if (!t) return;

                    t.style.visibility = 'visible'; // Make it visible to measure width
                    const r = this.getBoundingClientRect();
                    const tooltipWidth = t.offsetWidth;
                    t.style.visibility = ''; // Reset visibility

                    // Center horizontally
                    let left = r.left + (r.width / 2) - (tooltipWidth / 2);

                    // Clamp to screen edges
                    if (left < 10) left = 10;
                    if (left + tooltipWidth > window.innerWidth - 10) left = window.innerWidth - tooltipWidth - 10;

                    let top = r.top - t.offsetHeight - 10;
                    if (top < 10) top = r.bottom + 10;

                    // Prevent bottom overflow
                    if (top + t.offsetHeight > window.innerHeight) top = window.innerHeight - t.offsetHeight - 10;

                    t.style.left = left + 'px';
                    t.style.top = top + 'px';
                };
            });
        }


        // --- CHART LOGIC ---
        let timeFilterHours = 24; // Default 24 Hours

        function setPeriod(hours) {
            timeFilterHours = hours;

            // Update active button
            document.querySelectorAll('#timeControls button').forEach(b => b.classList.remove('active'));
            const btnId = hours === 0 ? 'btn0' : 'btn' + hours;
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('active');

            renderCharts();
            if (document.getElementById('chartModal').style.display === 'block') {
                // If modal is open, refresh it too (we need to know which item was opened)
                // For simplicity, we just close it or let user reopen. 
                // Ideally, store currentModalItem and refresh.
            }
        }


        function toggleAll(canvasId) {
            const chart = chartInstances[canvasId];
            if (!chart) return;

            let allHidden = true;
            for (let i = 0; i < chart.data.datasets.length; i++) {
                if (chart.isDatasetVisible(i)) {
                    allHidden = false;
                    break;
                }
            }

            chart.data.datasets.forEach((ds, i) => {
                ds.hidden = !allHidden;
                const meta = chart.getDatasetMeta(i);
                if (meta) meta.hidden = !allHidden ? true : null;
            });
            chart.update();
            generateCustomLegend(canvasId, chart);
        }


        function getFilteredData(row, metric) {
            const allLabels = row.labels;
            const allData = row.history[metric];

            // 1. Filter by time range
            let startIndex = 0;
            if (timeFilterHours > 0) {
                const cutoff = Date.now() / 1000 - (timeFilterHours * 3600);
                startIndex = allLabels.findIndex(t => t >= cutoff);
                if (startIndex === -1) return { labels: [], data: [] };
            }

            const filteredLabels = allLabels.slice(startIndex);
            const filteredData = allData.slice(startIndex);

            // 2. Determine aggregation interval
            let intervalSeconds = 0;
            if (timeFilterHours === 24) intervalSeconds = 3600;
            else if (timeFilterHours === 72) intervalSeconds = 3 * 3600;
            else if (timeFilterHours === 168) intervalSeconds = 7 * 3600;
            else if (timeFilterHours === 0) intervalSeconds = 12 * 3600;

            if (intervalSeconds === 0 || filteredLabels.length === 0) {
                return { labels: filteredLabels, data: filteredData };
            }

            // 3. Aggregate
            const aggLabels = [];
            const aggData = [];
            let bucketStartTime = filteredLabels[0];
            let sum = 0;
            let count = 0;

            for (let i = 0; i < filteredLabels.length; i++) {
                if (filteredLabels[i] < bucketStartTime + intervalSeconds) {
                    sum += filteredData[i];
                    count++;
                } else {
                    if (count > 0) {
                        aggLabels.push(bucketStartTime);
                        aggData.push(sum / count);
                    }
                    bucketStartTime = filteredLabels[i];
                    sum = filteredData[i];
                    count = 1;
                }
            }
            if (count > 0) {
                aggLabels.push(bucketStartTime);
                aggData.push(sum / count);
            }

            return {
                labels: aggLabels,
                data: aggData
            };
        }

        function formatLabels(timestamps) {
            return timestamps.map(ts => {
                if (typeof ts === 'string') return ts;
                const date = new Date(ts * 1000);

                if (timeFilterHours === 24) {
                    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                }

                const d = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const t = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                return `${d}, ${t}`;
            });
        }

        function generateCustomLegend(canvasId, chart) {
            const legendContainer = document.getElementById(canvasId + '-legend');
            legendContainer.innerHTML = '';

            // Helper to find dataset by item code
            const findDatasetIndex = (code) => chart.data.datasets.findIndex(ds => ds.itemCode === code);

            // Iterate defined groups
            for (const [groupName, items] of Object.entries(productionLines)) {
                // Check if any item in this group exists in chart
                const groupIndices = items.map(findDatasetIndex).filter(i => i !== -1);
                if (groupIndices.length === 0) continue;

                const groupDiv = document.createElement('div');
                groupDiv.className = 'legend-group';

                // Check if all items in this group are hidden
                const allGroupHidden = groupIndices.every(idx => {
                    const meta = chart.getDatasetMeta(idx);
                    return meta.hidden === null ? chart.data.datasets[idx].hidden : meta.hidden;
                });

                // Group Header (Toggle All in Group)
                const header = document.createElement('div');
                header.className = 'legend-group-header';
                header.innerText = groupName;
                if (allGroupHidden) {
                    header.style.opacity = '0.5';
                    header.style.textDecoration = 'line-through';
                }

                header.onclick = () => {
                    // Determine if we are hiding or showing based on group state
                    const newState = !allGroupHidden; // Toggle

                    groupIndices.forEach(idx => {
                        chart.getDatasetMeta(idx).hidden = newState ? true : null;
                        chart.data.datasets[idx].hidden = newState;
                    });
                    chart.update();
                    generateCustomLegend(canvasId, chart); // Re-render legend to update styles
                };
                groupDiv.appendChild(header);

                // Items
                groupIndices.forEach(idx => {
                    const ds = chart.data.datasets[idx];
                    const meta = chart.getDatasetMeta(idx);
                    const isHidden = meta.hidden === null ? ds.hidden : meta.hidden;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'legend-item' + (isHidden ? ' hidden' : '');
                    itemDiv.onclick = () => {
                        meta.hidden = isHidden ? null : true;
                        ds.hidden = !isHidden;
                        chart.update();
                        generateCustomLegend(canvasId, chart);
                    };

                    itemDiv.innerHTML = `<span class="legend-color" style="background:${ds.backgroundColor}"></span>${ds.label}`;
                    groupDiv.appendChild(itemDiv);
                });

                legendContainer.appendChild(groupDiv);
            }
        }

        function renderCharts() {
            if (!tableData.length) return;

            const fallbackColors = [
                '#4E79A7', '#F28E2B', '#E15759', '#76B7B2', '#59A14F',
                '#EDC948', '#B07AA1', '#FF9DA7', '#9C755F', '#BAB0AC',
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
            ];

            const isMobile = window.innerWidth <= 768;

            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                onClick: (evt) => {
                    if (!isMobile) return;
                    const chart = evt.chart;
                    const canvas = chart.canvas;

                    if (mobileAnnotation) {
                        mobileAnnotation.remove();
                        mobileAnnotation = null;
                    }

                    chart.data.datasets.forEach(dataset => {
                        dataset.pointRadius = 0;
                    });

                    const points = chart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, true);
                    if (points.length) {
                        const firstPoint = points[0];
                        const dataset = chart.data.datasets[firstPoint.datasetIndex];
                        const value = dataset.data[firstPoint.index];
                        const { x, y } = firstPoint.getProps(['x', 'y'], true);

                        const radii = new Array(dataset.data.length).fill(0);
                        radii[firstPoint.index] = 5;
                        dataset.pointRadius = radii;

                        const div = document.createElement('div');
                        div.style.position = 'absolute';
                        div.style.left = x + 'px';
                        div.style.top = y + 'px';
                        div.style.transform = 'translate(-50%, -150%)';
                        div.style.background = 'rgba(0,0,0,0.75)';
                        div.style.color = 'white';
                        div.style.padding = '4px 8px';
                        div.style.borderRadius = '4px';
                        div.style.fontSize = '12px';
                        div.style.pointerEvents = 'none';
                        div.style.whiteSpace = 'nowrap';
                        div.textContent = `${dataset.label}: ${value.toFixed(4)}`;
                        canvas.parentNode.appendChild(div);
                        mobileAnnotation = div;
                    }
                    chart.update('none');
                },
                plugins: {
                    legend: { display: false }, // We use a custom HTML legend
                    tooltip: {
                        enabled: !isMobile,
                        backgroundColor: '#2d3748',
                        titleColor: '#cbd5e0',
                        bodyColor: '#f7fafc',
                        borderColor: '#4a5568',
                        borderWidth: 1,
                        padding: 12,
                        cornerRadius: 8,
                        boxPadding: 6,
                        usePointStyle: true,
                        titleFont: { size: 14, weight: 'bold' },
                        bodyFont: { size: 13 },
                        yAlign: 'bottom', // Force tooltip to appear above the point
                        callbacks: {
                            label: function (context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.y !== null) label += context.parsed.y.toFixed(4);
                                return label;
                            }
                        }
                    },
                    title: {
                        display: false
                    }
                },
                scales: {
                    x: {
                        ticks: {
                            color: () => document.body.classList.contains('dark-mode') ? '#cbd5e0' : '#718096',
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 20
                        },
                        grid: {
                            color: () => document.body.classList.contains('dark-mode') ? 'rgba(160, 174, 192, 0.2)' : 'rgba(226, 232, 240, 0.7)'
                        }
                    },
                    y: {
                        type: 'linear',
                        beginAtZero: false,
                        ticks: {
                            color: () => document.body.classList.contains('dark-mode') ? '#cbd5e0' : '#718096',
                        },
                        grid: {
                            color: () => document.body.classList.contains('dark-mode') ? 'rgba(160, 174, 192, 0.2)' : 'rgba(226, 232, 240, 0.7)'
                        }
                    }
                }
            };

            function createChart(canvasId, metric, title) {
                let hiddenState = {};
                if (chartInstances[canvasId]) {
                    chartInstances[canvasId].data.datasets.forEach((ds, i) => {
                        const meta = chartInstances[canvasId].getDatasetMeta(i);
                        hiddenState[ds.label] = meta.hidden !== null ? meta.hidden : ds.hidden;
                    });
                    chartInstances[canvasId].destroy();
                }

                // Prepare datasets with filtering
                let chartLabels = [];
                const datasets = tableData.map((row, index) => {
                    const filtered = getFilteredData(row, currentMetric);
                    if (index === 0) chartLabels = formatLabels(filtered.labels); // Use labels from first item

                    const color = itemColors[row.item] || fallbackColors[index % fallbackColors.length];

                    return {
                        label: row.pretty_name,
                        itemCode: row.item, // Store item code for grouping
                        data: filtered.data,
                        borderColor: color,
                        backgroundColor: color,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0, // Hide points for cleaner look
                        pointHitRadius: 10,
                        borderWidth: 2,
                        hidden: hiddenState[row.pretty_name]
                    };
                });

                const ctx = document.getElementById(canvasId).getContext('2d');
                const finalOptions = JSON.parse(JSON.stringify(commonOptions)); // Deep copy

                // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ (—Ç–µ—Ä—è–µ—Ç—Å—è –ø—Ä–∏ JSON.stringify)
                if (!finalOptions.plugins.tooltip) finalOptions.plugins.tooltip = {};
                finalOptions.plugins.tooltip.itemSort = (a, b) => b.raw - a.raw;

                chartInstances[canvasId] = new Chart(ctx, {
                    type: 'line',
                    data: { labels: chartLabels, datasets: datasets },
                    options: finalOptions
                });

                generateCustomLegend(canvasId, chartInstances[canvasId]);
            }

            createChart('mainChart', currentMetric, '');
        }
        // Sync fidelity sort state on page load in case of browser cache
        sortByFidelity = document.getElementById('fidelitySort').checked;

        updateSortLabel();
        setMetric('min_pp'); // Set initial title

        window.addEventListener('resize', () => {
            renderTable();
        });

        renderTable();
        renderCharts();
    </script>
</body>

</html>